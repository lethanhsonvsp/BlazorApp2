@page "/"
@inject MotorManager Manager
@inject UbuntuCANInterface CANInterface
@using BlazorApp2.Services
@rendermode InteractiveServer

<style>
    .grid-container {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-auto-rows: auto;
        gap: 20px;
        padding: 10px;
    }

    .grid-item {
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 15px;
        background: #f9f9f9;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
    }

    .item-status {
        grid-column: span 1;
    }

    .item-control {
        grid-column: span 2;
    }

    .log-box {
        max-height: 250px;
        overflow-y: auto;
        font-family: monospace;
        background: #111;
        color: #0f0;
        padding: 10px;
        border-radius: 5px;
    }

    .tx {
        color: #0ff;
    }

    .rx {
        color: #0f0;
    }
</style>

<h3>Điều khiển Motor CiA402</h3>

<div class="grid-container">
    <!-- 1.1 Trạng thái -->
    <div class="grid-item item-status">
        <h3>Trạng thái</h3>
        <p>@(Manager.IsConnected ? "✅ Đã kết nối CAN" : "❌ Chưa kết nối")</p>
        <h5>Giá trị hiện tại</h5>
        <p>Vị trí: @position.ToString("F2")</p>
        <p>Vận tốc: @velocity.ToString("F2")</p>
        <p>Mô-men: @torque.ToString("F2")</p>
        <h3>Status: @statusDesc</h3>
    </div>

    <!-- 1.2 Điều khiển -->
    <div class="grid-item item-control">
        <h5>Điều khiển</h5>

        <div class="mb-3">
            <div class="btn-group mb-2" role="group">
                <button class="btn btn-primary" @onclick="DoConnect">Connect CAN</button>
                <button class="btn btn-secondary" @onclick="DoDisconnect">Disconnect CAN</button>
            </div>
            <div class="btn-group mb-2" role="group">
                <button class="btn btn-warning" @onclick="DoResetFault">Reset Fault</button>
                <button class="btn btn-secondary" @onclick="DoResetMotor">Reset Motor</button>
            </div>
            <div class="btn-group mb-2" role="group">
                <button class="btn btn-success" @onclick="DoEnableMotor">Enable Motor</button>
                <button class="btn btn-danger" @onclick="DoStopMotor">StopMotor</button>
                <button class="btn btn-info" @onclick="DoQuitMotor">QuitMotor</button>
                <button class="btn btn-warning" @onclick="DoDisableMotor">Disable Motor</button>
            </div>
        </div>

        <!-- Homing -->
        <div class="mb-3">
            <label>Homing Method</label>
            <div class="input-group">
                <input @bind="homingMethod" type="number" min="1" max="35" class="form-control" />
                <button class="btn btn-primary" @onclick="DoHoming">Bắt đầu Homing</button>
            </div>
        </div>

        <!-- Position -->
        <div class="mb-3">
            <label>Move to Position</label>
            <div class="input-group mb-1">
                <span class="input-group-text">Pos</span>
                <input @bind="targetPosition" type="number" step="0.01" class="form-control" />
                <span class="input-group-text">Vel</span>
                <input @bind="profileVel" type="number" step="0.01" class="form-control" />
            </div>
            <div class="input-group mb-1">
                <span class="input-group-text">Acc</span>
                <input @bind="acceleration" type="number" step="0.01" class="form-control" />
                <span class="input-group-text">Dec</span>
                <input @bind="deceleration" type="number" step="0.01" class="form-control" />
                <button class="btn btn-primary" @onclick="DoMove">Move</button>
            </div>
        </div>

        <!-- Velocity -->
        <div class="mb-3">
            <label>Set Velocity</label>
            <div class="input-group">
                <input @bind="targetVel" type="number" class="form-control" />
                <button class="btn btn-primary" @onclick="DoSetVelocity">Apply</button>
            </div>
        </div>

        <!-- Torque -->
        <div class="mb-3">
            <label>Set Torque</label>
            <div class="input-group">
                <input @bind="targetTorque" type="number" class="form-control" />
                <button class="btn btn-primary" @onclick="DoSetTorque">Apply</button>
            </div>
        </div>
    </div>

    <!-- 2.1 TX -->
    <div class="grid-item">
        <h5>CANopen Send (TX)</h5>
        <div class="log-box" id="txBox">
            @foreach (var log in txLogs)
            {
                <div class="tx">[@log.Timestamp:HH:mm:ss] → @log.Frame</div>
            }
        </div>
    </div>

    <!-- 2.2 RX -->
    <div class="grid-item">
        <h5>CANopen Receive (RX)</h5>
        <div class="log-box" id="rxBox">
            @foreach (var log in rxLogs)
            {
                <div class="rx">[@log.Timestamp:HH:mm:ss] ← @log.Frame</div>
            }
        </div>
    </div>

    <!-- 2.3 Log Message -->
    <div class="grid-item">
        <h5>Log Message</h5>
        <div class="log-box" id="logBox">
            @foreach (var log in logMessages)
            {
                <div>@($"[{log.Timestamp:HH:mm:ss}] {log.Msg}")</div>
            }
        </div>
    </div>
</div>

@code {
    double position = 0, velocity = 0, torque = 0;
    int homingMethod = 35;
    double targetPosition = 0, profileVel = 20, acceleration = 100, deceleration = 100;
    double targetVel = 0, targetTorque = 0;
    string statusDesc = "Đang chờ dữ liệu...";

    List<CanLogEntry> txLogs = new();
    List<CanLogEntry> rxLogs = new();
    List<CanLogEntry> logMessages = new();

    string? _lastRxFrame = null;
    System.Threading.CancellationTokenSource? _cts;

    protected override void OnInitialized()
    {
        _cts = new System.Threading.CancellationTokenSource();
        _ = Task.Run(() => UpdateLoop(_cts.Token));

        Manager.OnCanLog += (entry) =>
        {
            InvokeAsync(() =>
            {
                if (entry.Direction == "TX")
                {
                    txLogs.Insert(0, entry);
                    if (txLogs.Count > 200) txLogs.RemoveAt(txLogs.Count - 1);
                }
                else if (entry.Direction == "RX")
                {
                    if (_lastRxFrame != entry.Frame)
                    {
                        rxLogs.Insert(0, entry);
                        if (rxLogs.Count > 200) rxLogs.RemoveAt(rxLogs.Count - 1);
                        _lastRxFrame = entry.Frame;
                    }
                }

                logMessages.Insert(0, entry);
                if (logMessages.Count > 200) logMessages.RemoveAt(logMessages.Count - 1);

                StateHasChanged();
            });
        };
    }

    private async Task UpdateLoop(CancellationToken token)
    {
        try
        {
            while (!token.IsCancellationRequested)
            {
                double newPos = Manager.GetPosition();
                double newVel = Manager.GetVelocity();
                double newTorque = Manager.GetTorque();
                string newStatus = Manager.GetStatusDescription();

                bool changed = false;

                if (Math.Abs(newPos - position) > 0.001) { position = newPos; changed = true; }
                if (Math.Abs(newVel - velocity) > 0.001) { velocity = newVel; changed = true; }
                if (Math.Abs(newTorque - torque) > 0.001) { torque = newTorque; changed = true; }
                if (newStatus != statusDesc) { statusDesc = newStatus; changed = true; }

                if (changed)
                    await InvokeAsync(StateHasChanged);

                await Task.Delay(500, token);
            }
        }
        catch (OperationCanceledException) { }
    }

    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
    }

    void DoHoming() => Manager.StartHoming((byte)homingMethod);
    void DoMove() => Manager.MoveToPosition(targetPosition, (uint)profileVel, (uint)acceleration, (uint)deceleration);
    void DoSetVelocity() => Manager.SetVelocity(targetVel);
    void DoSetTorque() => Manager.SetTorque((short)targetTorque);
    void DoResetFault() => Manager.ResetFault();
    void DoResetMotor() => Manager.ResetMotor();
    void DoEnableMotor() => Manager.ResetFaultAndEnable();
    void DoConnect() => Manager.Connect();
    void DoDisconnect() => Manager.Disconnect();
    void DoStopMotor() => Manager.StopMotor();
    void DoDisableMotor() => Manager.DisableMotor();
    void DoQuitMotor() => Manager.QuickStop();

}
